const e=JSON.parse(`{"key":"v-3118468a","path":"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%9F%B3/JS%E5%9F%BA%E7%A1%80/js%E6%96%B9%E6%B3%95%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0.html","title":"js方法手动实现","lang":"zh-CN","frontmatter":{"title":"js方法手动实现","tag":"JS基础","date":"2019-06-12T00:00:00.000Z","category":["前端基石"],"description":"js 方法手动实现 1.实现 Object.assign(target,obj,obj1) Object.assign 是浅拷贝,对于值是引用类型的属性,拷贝仍旧的是它的引用 可以拷贝 Symbol 属性 不能拷贝不可枚举的属性 Object.assign 保证 target 始终是一个对象,如果传入一个基本类型,会转为基本包装类型,null/undefined 没有基本包装类型,所以传入会报错 source 参数如果是不可枚举的数据类型会忽略合并(字符串类型被认为是可枚举的,因为内部有 iterator 接口) 因为是用等号进行赋值,如果被赋值的对象的属性有 setter 函数会触发 setter 函数,同理如果有 getter 函数,也会调用赋值对象的属性的 getter 函数(这就是为什么 Object.assign 无法合并对象属性的访问器,因为它会直接执行对应的 getter/setter 函数而不是合并它们,如果需要合并对象属性的 getter/setter 函数,可以使用 ES7 提供的 Object.getOwnPropertyDescriptors 和 Object.defineProperties 这 2 个 API 实现)","head":[["meta",{"property":"og:url","content":"http://magicbegin.gitee.io/vuepress-blog/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%9F%B3/JS%E5%9F%BA%E7%A1%80/js%E6%96%B9%E6%B3%95%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0.html"}],["meta",{"property":"og:site_name","content":"Mr Chen's Blog"}],["meta",{"property":"og:title","content":"js方法手动实现"}],["meta",{"property":"og:description","content":"js 方法手动实现 1.实现 Object.assign(target,obj,obj1) Object.assign 是浅拷贝,对于值是引用类型的属性,拷贝仍旧的是它的引用 可以拷贝 Symbol 属性 不能拷贝不可枚举的属性 Object.assign 保证 target 始终是一个对象,如果传入一个基本类型,会转为基本包装类型,null/undefined 没有基本包装类型,所以传入会报错 source 参数如果是不可枚举的数据类型会忽略合并(字符串类型被认为是可枚举的,因为内部有 iterator 接口) 因为是用等号进行赋值,如果被赋值的对象的属性有 setter 函数会触发 setter 函数,同理如果有 getter 函数,也会调用赋值对象的属性的 getter 函数(这就是为什么 Object.assign 无法合并对象属性的访问器,因为它会直接执行对应的 getter/setter 函数而不是合并它们,如果需要合并对象属性的 getter/setter 函数,可以使用 ES7 提供的 Object.getOwnPropertyDescriptors 和 Object.defineProperties 这 2 个 API 实现)"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-27T11:35:00.000Z"}],["meta",{"property":"article:author","content":"Mr Chen"}],["meta",{"property":"article:tag","content":"JS基础"}],["meta",{"property":"article:published_time","content":"2019-06-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-27T11:35:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"js方法手动实现\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-06-12T00:00:00.000Z\\",\\"dateModified\\":\\"2023-10-27T11:35:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr Chen\\",\\"url\\":\\"https://gitee.com/magicBegin/vuepress-blog\\",\\"email\\":\\"599422271@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"js 方法手动实现","slug":"js-方法手动实现","link":"#js-方法手动实现","children":[{"level":3,"title":"1.实现 Object.assign(target,obj,obj1)","slug":"_1-实现-object-assign-target-obj-obj1","link":"#_1-实现-object-assign-target-obj-obj1","children":[]},{"level":3,"title":"2.实现函数 bind 方法","slug":"_2-实现函数-bind-方法","link":"#_2-实现函数-bind-方法","children":[]},{"level":3,"title":"3.实现函数 call 方法","slug":"_3-实现函数-call-方法","link":"#_3-实现函数-call-方法","children":[]},{"level":3,"title":"9. 实现 es6 的 class 语法","slug":"_9-实现-es6-的-class-语法","link":"#_9-实现-es6-的-class-语法","children":[]},{"level":3,"title":"10.函数柯里化","slug":"_10-函数柯里化","link":"#_10-函数柯里化","children":[]},{"level":3,"title":"11.函数防抖","slug":"_11-函数防抖","link":"#_11-函数防抖","children":[]},{"level":3,"title":"12.优雅的处理 async/await","slug":"_12-优雅的处理-async-await","link":"#_12-优雅的处理-async-await","children":[]},{"level":3,"title":"13.手写 前端状态管理器","slug":"_13-手写-前端状态管理器","link":"#_13-手写-前端状态管理器","children":[]}]}],"git":{"createdTime":1698406500000,"updatedTime":1698406500000,"contributors":[{"name":"chenzhen","email":"599422271@qq.com","commits":1}]},"readingTime":{"minutes":8.66,"words":2597},"filePathRelative":"前端开发/前端基石/JS基础/js方法手动实现.md","localizedDate":"2019年6月12日","excerpt":"<h2> js 方法手动实现</h2>\\n<h3> 1.实现 Object.assign(target,obj,obj1)</h3>\\n<ul>\\n<li>Object.assign 是浅拷贝,对于值是引用类型的属性,拷贝仍旧的是它的引用</li>\\n<li>可以拷贝 Symbol 属性</li>\\n<li>不能拷贝不可枚举的属性</li>\\n<li>Object.assign 保证 target 始终是一个对象,如果传入一个基本类型,会转为基本包装类型,null/undefined 没有基本包装类型,所以传入会报错</li>\\n<li>source 参数如果是不可枚举的数据类型会忽略合并(字符串类型被认为是可枚举的,因为内部有 iterator 接口)</li>\\n<li>因为是用等号进行赋值,如果被赋值的对象的属性有 setter 函数会触发 setter 函数,同理如果有 getter 函数,也会调用赋值对象的属性的 getter 函数(这就是为什么 Object.assign 无法合并对象属性的访问器,因为它会直接执行对应的 getter/setter 函数而不是合并它们,如果需要合并对象属性的 getter/setter 函数,可以使用 ES7 提供的 Object.getOwnPropertyDescriptors 和 Object.defineProperties 这 2 个 API 实现)</li>\\n</ul>","autoDesc":true}`);export{e as data};
