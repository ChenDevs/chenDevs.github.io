import { effect, onDispose } from 'maverick.js';
import { useDisposalBin, listenEvent, DOMEvent, isNil } from 'maverick.js/std';
import { R as RAFLoop } from '../hls/hls.js';
import { i as isHLSSrc } from '../audio/loader.js';
import { y as getNumberOfDecimalPlaces } from '../../media-ui.js';
import { I as IS_SAFARI } from '../../media-core.js';

class HTMLMediaEvents {
  constructor(_provider, _context) {
    this.j = _provider;
    this.ph = _context;
    this.Fh();
    effect(this.Gh.bind(this));
    onDispose(this.Hh.bind(this));
  }
  ih = useDisposalBin();
  yh = false;
  Bh = false;
  Ch = false;
  zh = new RAFLoop(this.Ih.bind(this));
  get k() {
    return this.j.media;
  }
  get jg() {
    return this.ph.delegate;
  }
  Hh() {
    this.zh.K();
    this.ih.empty();
  }
  /**
   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
   * resolve that by retrieving time updates in a request animation frame loop.
   */
  Ih() {
    const newTime = this.j.currentTime;
    if (this.ph.$store.currentTime() !== newTime)
      this.xh(newTime);
  }
  Fh() {
    this.wh("loadstart", this.ge);
    this.wh("abort", this.Dh);
    this.wh("emptied", this.Jh);
    this.wh("error", this.Wb);
  }
  Kh() {
    if (this.Bh)
      return;
    this.ih.add(
      this.wh("loadeddata", this.Lh),
      this.wh("loadedmetadata", this.Mh),
      this.wh("canplay", this.Rb),
      this.wh("canplaythrough", this.Nh),
      this.wh("durationchange", this.Oh),
      this.wh("play", this.Ph),
      this.wh("progress", this.Qh),
      this.wh("stalled", this.Rh),
      this.wh("suspend", this.Sh)
    );
    this.Bh = true;
  }
  Th() {
    if (this.Ch)
      return;
    this.ih.add(
      this.wh("pause", this.Uh),
      this.wh("playing", this.Vh),
      this.wh("ratechange", this.Wh),
      this.wh("seeked", this.Xh),
      this.wh("seeking", this.Yh),
      this.wh("ended", this.Zh),
      this.wh("volumechange", this.ac),
      this.wh("waiting", this._h)
    );
    this.Ch = true;
  }
  $h = void 0;
  bi = void 0;
  wh(eventType, handler) {
    return listenEvent(
      this.k,
      eventType,
      handler.bind(this)
    );
  }
  ci(event2) {
    return;
  }
  xh(time, trigger) {
    this.jg.R("time-update", {
      // Avoid errors where `currentTime` can have higher precision.
      detail: {
        currentTime: Math.min(time, this.ph.$store.seekableEnd()),
        played: this.k.played
      },
      trigger
    });
  }
  ge(event2) {
    if (this.k.networkState === 3) {
      this.Dh(event2);
      return;
    }
    this.Kh();
    this.jg.R("load-start", { trigger: event2 });
  }
  Dh(event2) {
    this.jg.R("abort", { trigger: event2 });
  }
  Jh() {
    this.jg.R("emptied", { trigger: event });
  }
  Lh(event2) {
    this.jg.R("loaded-data", { trigger: event2 });
  }
  Mh(event2) {
    this.Eh();
    this.Th();
    this.jg.R("volume-change", {
      detail: {
        volume: this.k.volume,
        muted: this.k.muted
      }
    });
    this.jg.R("loaded-metadata", { trigger: event2 });
    if (IS_SAFARI && isHLSSrc(this.ph.$store.source())) {
      this.jg.af(this.Ah(), event2);
    }
  }
  Ah() {
    return {
      duration: this.k.duration,
      buffered: this.k.buffered,
      seekable: this.k.seekable
    };
  }
  Eh() {
    const isLive = !Number.isFinite(this.k.duration);
    this.jg.R("stream-type-change", {
      detail: isLive ? "live" : "on-demand"
    });
  }
  Ph(event2) {
    if (!this.ph.$store.canPlay)
      return;
    this.jg.R("play", { trigger: event2 });
  }
  Uh(event2) {
    if (this.k.readyState === 1 && !this.yh)
      return;
    this.yh = false;
    this.zh.K();
    this.jg.R("pause", { trigger: event2 });
  }
  Rb(event2) {
    this.jg.af(this.Ah(), event2);
  }
  Nh(event2) {
    if (this.ph.$store.started())
      return;
    this.jg.R("can-play-through", {
      trigger: event2,
      detail: this.Ah()
    });
  }
  Vh(event2) {
    this.yh = false;
    this.jg.R("playing", { trigger: event2 });
    this.zh.J();
  }
  Rh(event2) {
    this.jg.R("stalled", { trigger: event2 });
    if (this.k.readyState < 3) {
      this.yh = true;
      this.jg.R("waiting", { trigger: event2 });
    }
  }
  _h(event2) {
    if (this.k.readyState < 3) {
      this.yh = true;
      this.jg.R("waiting", { trigger: event2 });
    }
  }
  Zh(event2) {
    this.zh.K();
    this.xh(this.k.duration, event2);
    this.jg.R("end", { trigger: event2 });
    if (this.ph.$store.loop()) {
      this.ai();
    } else {
      this.jg.R("ended", { trigger: event2 });
    }
  }
  Gh() {
    if (this.ph.$store.paused()) {
      listenEvent(this.k, "timeupdate", this.Vb.bind(this));
    }
  }
  Vb(event2) {
    this.xh(this.k.currentTime, event2);
  }
  Oh(event2) {
    this.Eh();
    if (this.ph.$store.ended()) {
      this.xh(this.k.duration, event2);
    }
    this.jg.R("duration-change", {
      detail: this.k.duration,
      trigger: event2
    });
  }
  ac(event2) {
    this.jg.R("volume-change", {
      detail: {
        volume: this.k.volume,
        muted: this.k.muted
      },
      trigger: event2
    });
  }
  Xh(event2) {
    this.xh(this.k.currentTime, event2);
    this.jg.R("seeked", {
      detail: this.k.currentTime,
      trigger: event2
    });
    if (Math.trunc(this.k.currentTime) === Math.trunc(this.k.duration) && getNumberOfDecimalPlaces(this.k.duration) > getNumberOfDecimalPlaces(this.k.currentTime)) {
      this.xh(this.k.duration, event2);
      if (!this.k.ended) {
        this.ph.player.dispatchEvent(
          new DOMEvent("media-play-request", {
            trigger: event2
          })
        );
      }
    }
  }
  Yh(event2) {
    this.jg.R("seeking", {
      detail: this.k.currentTime,
      trigger: event2
    });
  }
  Qh(event2) {
    this.jg.R("progress", {
      detail: {
        buffered: this.k.buffered,
        seekable: this.k.seekable
      },
      trigger: event2
    });
  }
  ai() {
    const hasCustomControls = isNil(this.k.controls);
    if (hasCustomControls)
      this.k.controls = false;
    this.ph.player.dispatchEvent(new DOMEvent("media-loop-request"));
  }
  Sh(event2) {
    this.jg.R("suspend", { trigger: event2 });
  }
  Wh(event2) {
    this.jg.R("rate-change", {
      detail: this.k.playbackRate,
      trigger: event2
    });
  }
  Wb(event2) {
    const error = this.k.error;
    if (!error)
      return;
    this.jg.R("error", {
      detail: {
        message: error.message,
        code: error.code,
        mediaError: error
      },
      trigger: event2
    });
  }
}

export { HTMLMediaEvents as H };
