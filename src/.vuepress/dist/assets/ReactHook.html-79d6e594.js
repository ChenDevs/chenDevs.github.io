const e=JSON.parse(`{"key":"v-176aef0e","path":"/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/ReactHook.html","title":"React Hook","lang":"zh-CN","frontmatter":{"title":"React Hook","order":8,"category":["前端框架","React"],"icon":"hook","description":"// TODO 待修改 Class 组件存在的问题 复杂组件变得难以理解： 我们在最初编写一个 class 组件时，往往逻辑比较简单，并不会非常复杂。但是随着业务的增多，我们的 class 组件会变得越来越复杂 比如 componentDidMount 中，可能就会包含大量的逻辑代码：包括网络请求、一些事件的监听（还需要在 componentWillUnmount 中移除） 而对于这样的 class 实际上非常难以拆分：因为它们的逻辑往往混在一起，强行拆分反而会造成过度设计，增加代码的复杂度 难以理解的 class： 很多人发现学习 ES6 的 class 是学习 React 的一个障碍 比如在 class 中，我们必须搞清楚 this 的指向到底是谁 实现组件状态逻辑复用很难: 在前面为了组件状态逻辑复用我们需要通过高阶组件或 render props(🔎 详情见 react 组件化) 像我们之前学习的 redux 中 connect 或者 react-router 中的 withRouter，这些高阶组件设计的目的就是为了状态的复用 或者类似于 Provider、Consumer 来共享一些状态，但是多次使用 Consumer 时，我们的代码就会存在很多嵌套 这些代码让我们不管是编写和设计上来说，都变得非常困难","head":[["meta",{"property":"og:url","content":"http://magicbegin.gitee.io/vuepress-blog/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/ReactHook.html"}],["meta",{"property":"og:site_name","content":"Mr Chen's Blog"}],["meta",{"property":"og:title","content":"React Hook"}],["meta",{"property":"og:description","content":"// TODO 待修改 Class 组件存在的问题 复杂组件变得难以理解： 我们在最初编写一个 class 组件时，往往逻辑比较简单，并不会非常复杂。但是随着业务的增多，我们的 class 组件会变得越来越复杂 比如 componentDidMount 中，可能就会包含大量的逻辑代码：包括网络请求、一些事件的监听（还需要在 componentWillUnmount 中移除） 而对于这样的 class 实际上非常难以拆分：因为它们的逻辑往往混在一起，强行拆分反而会造成过度设计，增加代码的复杂度 难以理解的 class： 很多人发现学习 ES6 的 class 是学习 React 的一个障碍 比如在 class 中，我们必须搞清楚 this 的指向到底是谁 实现组件状态逻辑复用很难: 在前面为了组件状态逻辑复用我们需要通过高阶组件或 render props(🔎 详情见 react 组件化) 像我们之前学习的 redux 中 connect 或者 react-router 中的 withRouter，这些高阶组件设计的目的就是为了状态的复用 或者类似于 Provider、Consumer 来共享一些状态，但是多次使用 Consumer 时，我们的代码就会存在很多嵌套 这些代码让我们不管是编写和设计上来说，都变得非常困难"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-27T11:35:00.000Z"}],["meta",{"property":"article:author","content":"Mr Chen"}],["meta",{"property":"article:modified_time","content":"2023-10-27T11:35:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React Hook\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-10-27T11:35:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr Chen\\",\\"url\\":\\"https://gitee.com/magicBegin/vuepress-blog\\",\\"email\\":\\"599422271@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"Class 组件存在的问题","slug":"class-组件存在的问题","link":"#class-组件存在的问题","children":[]},{"level":2,"title":"为什么需要 Hook？","slug":"为什么需要-hook","link":"#为什么需要-hook","children":[]},{"level":2,"title":"Hook 的出现","slug":"hook-的出现","link":"#hook-的出现","children":[]},{"level":2,"title":"Hook 规则","slug":"hook-规则","link":"#hook-规则","children":[]},{"level":2,"title":"useState","slug":"usestate","link":"#usestate","children":[{"level":3,"title":"函数式更新","slug":"函数式更新","link":"#函数式更新","children":[]}]},{"level":2,"title":"useEffect","slug":"useeffect","link":"#useeffect","children":[{"level":3,"title":"需要清除 Effect","slug":"需要清除-effect","link":"#需要清除-effect","children":[]},{"level":3,"title":"使用多个 Effect","slug":"使用多个-effect","link":"#使用多个-effect","children":[]},{"level":3,"title":"Effect 性能优化","slug":"effect-性能优化","link":"#effect-性能优化","children":[]}]},{"level":2,"title":"useContext","slug":"usecontext","link":"#usecontext","children":[]},{"level":2,"title":"useReducer","slug":"usereducer","link":"#usereducer","children":[]},{"level":2,"title":"useCallback","slug":"usecallback","link":"#usecallback","children":[]},{"level":2,"title":"useMemo","slug":"usememo","link":"#usememo","children":[{"level":3,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]}]},{"level":2,"title":"useRef","slug":"useref","link":"#useref","children":[]},{"level":2,"title":"useImperativeHandle","slug":"useimperativehandle","link":"#useimperativehandle","children":[]},{"level":2,"title":"useLayoutEffect","slug":"uselayouteffect","link":"#uselayouteffect","children":[]},{"level":2,"title":"自定义 Hook","slug":"自定义-hook","link":"#自定义-hook","children":[{"level":3,"title":"案例 1:所有的组件在创建和销毁时都进行打印","slug":"案例-1-所有的组件在创建和销毁时都进行打印","link":"#案例-1-所有的组件在创建和销毁时都进行打印","children":[]},{"level":3,"title":"案例 2:Context 的共享","slug":"案例-2-context-的共享","link":"#案例-2-context-的共享","children":[]},{"level":3,"title":"案例 2:获取滚动位置","slug":"案例-2-获取滚动位置","link":"#案例-2-获取滚动位置","children":[]},{"level":3,"title":"案例 3：localStorage 存储","slug":"案例-3-localstorage-存储","link":"#案例-3-localstorage-存储","children":[]}]},{"level":2,"title":"redux hooks","slug":"redux-hooks","link":"#redux-hooks","children":[]}],"git":{"createdTime":1698406500000,"updatedTime":1698406500000,"contributors":[{"name":"chenzhen","email":"599422271@qq.com","commits":1}]},"readingTime":{"minutes":14.29,"words":4286},"filePathRelative":"前端开发/前端框架/React/ReactHook.md","localizedDate":"2023年10月27日","excerpt":"<p>// TODO 待修改</p>\\n<h2> Class 组件存在的问题</h2>\\n<ol>\\n<li>\\n<p>复杂组件变得难以理解：</p>\\n<p>我们在最初编写一个 <code>class</code> 组件时，往往逻辑比较简单，并不会非常复杂。但是随着业务的增多，我们的 class 组件会变得越来越复杂</p>\\n<p>比如 componentDidMount 中，可能就会包含大量的逻辑代码：包括网络请求、一些事件的监听（还需要在 componentWillUnmount 中移除）</p>\\n<p>而对于这样的 class 实际上非常难以拆分：因为它们的逻辑往往混在一起，强行拆分反而会造成过度设计，增加代码的复杂度</p>\\n</li>\\n<li>\\n<p>难以理解的 class：</p>\\n<p>很多人发现学习 ES6 的 class 是学习 React 的一个障碍</p>\\n<p>比如在 class 中，我们必须搞清楚 this 的指向到底是谁</p>\\n</li>\\n<li>\\n<p><a href=\\"https://blog.csdn.net/w_D_lufei/article/details/104091014\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">实现组件状态逻辑复用</a>很难:</p>\\n<p>在前面为了组件状态逻辑复用我们需要通过高阶组件或 render props(<strong>🔎 详情见 react 组件化</strong>)</p>\\n<p>像我们之前学习的 redux 中 connect 或者 react-router 中的 withRouter，这些高阶组件设计的目的就是为了状态的复用</p>\\n<p>或者类似于 Provider、Consumer 来共享一些状态，但是多次使用 Consumer 时，我们的代码就会存在很多嵌套</p>\\n<p><strong>这些代码让我们不管是编写和设计上来说，都变得非常困难</strong></p>\\n</li>\\n</ol>","autoDesc":true}`);export{e as data};
